<!-- Author: Jimmy Wu -->
<!-- Date: October 2024 -->
<!-- WebXR teleop with Arm/Base/Auto/Off modes -->

<!doctype html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <style>
      body {
        background-color: #F0F0F0;
        font: 1rem/1.4 -apple-system, BlinkMacSystemFont,
          Segoe UI, Roboto, Oxygen,
          Ubuntu, Cantarell, Fira Sans,
          Droid Sans, Helvetica Neue, sans-serif;
        margin: 0;
      }

      header {
        padding: 0.5em;
        background-color: rgba(255, 255, 255, 0.90);
        display: flex;
        flex-direction: column;
        gap: 0.5em;
      }

      #info {
        font-size: 0.9em;
        background-color: rgba(240, 240, 240, 0.5);
      }

      #controls {
        display: flex;
        gap: 0.5em;
        margin-top: 0.25em;
      }

      #controls button {
        flex: 1;
        padding: 0.4em 0.6em;
        font-size: 0.95rem;
        border-radius: 8px;
        border: 1px solid #ccc;
        background-color: #f5f5f5;
      }

      #controls button.active.arm {
        background-color: #007aff;
        color: white;
      }

      #controls button.active.base {
        background-color: #ff3b30;
        color: white;
      }

      #controls button.active.auto {
        background-color: #34c759;
        color: white;
      }

      #controls button.active.off {
        background-color: #666;
        color: white;
      }

      #status {
        font-size: 0.85em;
      }

      canvas {
        position: absolute;
        z-index: 0;
        width: 100%;
        height: 100%;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        margin: 0;
        touch-action: none;
      }
    </style>
  </head>
  <body>
    <div id="overlay">
      <header>
        <!-- WebXR button will be injected here -->
        <div id="info">RTT: â€“</div>
        <div id="controls">
          <button id="armButton">Arm</button>
          <button id="baseButton">Base</button>
          <button id="autoButton">Auto</button>
          <button id="offButton">Off</button>
        </div>
        <div id="status">Mode: off | Touch & hold to teleop</div>
      </header>
    </div>

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script type="module">
      import { WebXRButton } from '/static/js/webxr-button.js';

      // ---------- Teleop / RTT state ----------

      const deviceId = Math.random().toString(36).substring(2, 15);

      class RTTStats {
        constructor(bufferSize) {
          this.bufferSize = bufferSize;
          this.bufferIndex = 0;
          this.rttArray = new Array(bufferSize).fill(0);
        }
        calculate(rtt) {
          this.rttArray[this.bufferIndex] = rtt;
          this.bufferIndex = (this.bufferIndex + 1) % this.bufferSize;
          const minRtt = Math.min(...this.rttArray);
          const avgRtt = this.rttArray.reduce((a, c) => a + c, 0) / this.bufferSize;
          const maxRtt = Math.max(...this.rttArray);
          const stdDev = Math.sqrt(
            this.rttArray
              .map((x) => (x - avgRtt) ** 2)
              .reduce((a, c) => a + c, 0) / this.bufferSize
          );
          return `${minRtt.toFixed(1)}/${avgRtt.toFixed(1)}/${maxRtt.toFixed(1)}/${stdDev.toFixed(1)} ms`;
        }
      }
      const rttStats = new RTTStats(100);

      const socket = io();
      socket.on('echo', (timestamp) => {
        const rtt = Date.now() - timestamp;
        document.getElementById('info').innerText =
          'RTT (min/avg/max/std): ' + rttStats.calculate(rtt);
      });

      // controlMode: how user wants to choose mode: 'arm' | 'base' | 'auto' | 'off'
      let controlMode = 'off';
      // currentTeleopMode: actual mode used for the current touch: 'arm' | 'base' | null
      let currentTeleopMode = null;

      let touchId;
      let touchStartY;
      let touchDeltaY = 0;

      const armBtn  = document.getElementById('armButton');
      const baseBtn = document.getElementById('baseButton');
      const autoBtn = document.getElementById('autoButton');
      const offBtn  = document.getElementById('offButton');

      function updateButtons() {
        armBtn.className  = '';
        baseBtn.className = '';
        autoBtn.className = '';
        offBtn.className  = '';

        if (controlMode === 'arm') {
          armBtn.classList.add('active', 'arm');
        } else if (controlMode === 'base') {
          baseBtn.classList.add('active', 'base');
        } else if (controlMode === 'auto') {
          autoBtn.classList.add('active', 'auto');
        } else {
          offBtn.classList.add('active', 'off');
        }
        updateStatus();
      }

      function updateStatus() {
        const parts = [];
        parts.push('Mode: ' + controlMode);
        if (touchId !== undefined) {
          parts.push('Touch: active');
          if (currentTeleopMode) {
            parts.push('teleop=' + currentTeleopMode);
          }
          if (currentTeleopMode === 'arm') {
            parts.push('gripper_delta=' + touchDeltaY.toFixed(2));
          }
        } else {
          parts.push('Touch & hold to teleop');
        }
        document.getElementById('status').innerText = parts.join(' | ');
      }

      armBtn.addEventListener('click', () => {
        controlMode = 'arm';
        updateButtons();
      });
      baseBtn.addEventListener('click', () => {
        controlMode = 'base';
        updateButtons();
      });
      autoBtn.addEventListener('click', () => {
        controlMode = 'auto';
        updateButtons();
      });
      offBtn.addEventListener('click', () => {
        controlMode = 'off';
        updateButtons();
      });

      updateButtons();

      // ---------- WebXR setup ----------

      let xrButton = null;
      let xrRefSpace = null;
      let gl = null;

      function initXR() {
        xrButton = new WebXRButton({
          onRequestSession,
          onPrepareEndSession,
          onEndSession,
          textEnterXRTitle: 'Start episode',
          textXRNotFoundTitle: 'AR NOT FOUND',
          textPrepareExitXRTitle: 'End episode',
          textExitXRTitle: 'Reset env',
        });
        document.querySelector('header').appendChild(xrButton.domElement);

        if (navigator.xr) {
          navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
            xrButton.enabled = supported;
          });
        }
      }

      function onRequestSession() {
        return navigator.xr.requestSession('immersive-ar', {
          optionalFeatures: ['dom-overlay'],
          domOverlay: { root: document.getElementById('overlay') },
        }).then((session) => {
          xrButton.setSession(session);
          session.isImmersive = true;
          onSessionStarted(session);
        });
      }

      function onSessionStarted(session) {
        session.addEventListener('end', onSessionEnded);
        const canvas = document.createElement('canvas');
        gl = canvas.getContext('webgl', { xrCompatible: true });

        addCanvasListeners(gl.canvas);

        session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });
        session.requestReferenceSpace('local').then((refSpace) => {
          xrRefSpace = refSpace;
          session.requestAnimationFrame(onXRFrame);
        });

        // Tell server episode started
        socket.send({ timestamp: Date.now(), state_update: 'episode_started' });
      }

      function onPrepareEndSession() {
        socket.send({ timestamp: Date.now(), state_update: 'episode_ended' });
      }

      function onEndSession(session) {
        session.end();
        socket.send({ timestamp: Date.now(), state_update: 'reset_env' });
      }

      function onSessionEnded(event) {
        xrButton.setSession(null);
        gl = null;
      }

      // ---------- Touch handling (deadman + mode selection in AUTO) ----------

      function addCanvasListeners(canvas) {
        function handleTouch(touch) {
          touchDeltaY = (touchStartY - touch.clientY) / (0.2 * window.innerHeight);
          touchDeltaY = Math.min(1, Math.max(-1, touchDeltaY));
          updateStatus();
        }

        canvas.addEventListener('touchstart', (event) => {
          if (touchId === undefined) {
            const touch = event.changedTouches[0];
            touchId = touch.identifier;
            touchStartY = touch.clientY;

            // Decide teleop mode for THIS touch
            if (controlMode === 'arm' || controlMode === 'base') {
              // Explicit modes from buttons
              currentTeleopMode = controlMode;
            } else if (controlMode === 'auto') {
              // ORIGINAL BEHAVIOR: left/right to choose arm/base
              currentTeleopMode =
                touch.clientX < 0.9 * window.innerWidth ? 'arm' : 'base';
            } else {
              // off
              currentTeleopMode = null;
            }

            handleTouch(touch);
          }
        });

        canvas.addEventListener('touchmove', (event) => {
          for (const touch of event.changedTouches) {
            if (touchId === touch.identifier) {
              handleTouch(touch);
            }
          }
        });

        function clearTouch(event) {
          for (const touch of event.changedTouches) {
            if (touchId === touch.identifier) {
              touchId = undefined;
              touchDeltaY = 0;
              currentTeleopMode = null;
              updateStatus();
            }
          }
        }
        canvas.addEventListener('touchend', clearTouch);
        canvas.addEventListener('touchcancel', clearTouch);
      }

      // ---------- XR frame loop ----------

      function onXRFrame(t, frame) {
        frame.session.requestAnimationFrame(onXRFrame);

        // Visualize mode: red for base, blue for arm, when touching
        if (gl) {
          let r = 0, b = 0;
          if (touchId !== undefined && currentTeleopMode === 'base') {
            r = 0.25;
          } else if (touchId !== undefined && currentTeleopMode === 'arm') {
            b = (Math.abs(touchDeltaY) === 1 ? 1 : 0.25 + 0.25 * touchDeltaY);
          }
          gl.clearColor(r, 0, b, 0.5);
          gl.clear(gl.COLOR_BUFFER_BIT);
        }

        const data = { timestamp: Date.now(), device_id: deviceId };

        // Only send teleop commands if:
        //   - user is touching (deadman)
        //   - AND we have a concrete mode (arm/base)
        if (touchId !== undefined && currentTeleopMode) {
          const pose = frame.getViewerPose(xrRefSpace);
          if (pose) {
            const transform = pose.transform.inverse;
            data.teleop_mode = currentTeleopMode;
            data.position = {
              x: transform.position.x,
              y: transform.position.y,
              z: transform.position.z,
            };
            data.orientation = {
              x: transform.orientation.x,
              y: transform.orientation.y,
              z: transform.orientation.z,
              w: transform.orientation.w,
            };
          }
          if (currentTeleopMode === 'arm') {
            data.gripper_delta = touchDeltaY;
          }
        }

        socket.send(data);
      }

      initXR();
    </script>
  </body>
</html>
